{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Another Terry Attempt at Notes Right now this is stored at github in the new_mkdocs repository Be sure to do a git pull before using since I'm playing with it from both the Raspberry Pi 400 in the basement and the Beelink i5 in the 2nd floor office. Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Another Terry Attempt at Notes"},{"location":"#another-terry-attempt-at-notes","text":"Right now this is stored at github in the new_mkdocs repository Be sure to do a git pull before using since I'm playing with it from both the Raspberry Pi 400 in the basement and the Beelink i5 in the 2nd floor office.","title":"Another Terry Attempt at Notes"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/","text":"Chapter 1 Initial Setup Build websites with Python & Django William S. Vincent Create a folder where we're going to build our first project. mkdir code # Create a directory for our projects cd code # Change to that directory mkdir ch1-setup # Make a subdirectory for Chapter 1 cd ch1-setup # Change to that subdirectory To create a virtual environment within this new directory use the format: python3 -m venv <name_of_env> # This creates a venv It is up to the developer to choose a proper environment name but a common choice is to call it .venv. That hides the venv and is therefore one less piece of clutter on screens. Activate the virtual environment source .venv/bin/activate The shell prompt now has the environment name (.venv) prefixed which indicates that the virtual environment is active. Any Python packages installed or updated within this location will be confined to the active virtual environment. To deactivate and leave a virtual environment type deactivate . Install Django python -m pip install django~=4.0.0 The comparison operator \u223c= ensures that subsequent security updates for Django, such as 4.0.1, 4.0.2, and so on are automatically installed. Note that while it is possible to use the shorter version of pip install , it is a best practice to use the longer but more explicit form of python -m pip install to ensure that the correct version of Python is used. This can be an issue if you have multiple versions of Python installed on your computer. First Django Project A Django project can have almost any name but we will use django_project in this book. (.venv) > django-admin startproject django_project . It\u2019s worth pausing here to explain why you should add a period (.) to the end of the previous command. If you don't include the period, Django creates another django_project directory. This feels redundant to me which is why I prefer adding a period to the end which installs Django in the current directory. Runserver to test installation Now let\u2019s confirm everything is working by running Django\u2019s internal web server via the runserver command. This is suitable for local development purposes, but when it comes time to deploy our project\u2019s online we will switch to a more robust WSGI server like Gunicorn. python manage.py runserver Code Editor and Git Make sure you have a code editor and git installed. He recommends both the microsoft python extension for vscode and an extension called black which formats python code.","title":"Chapter 1 Initial Setup"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#chapter-1-initial-setup","text":"","title":"Chapter 1 Initial Setup"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#build-websites-with-python-django","text":"","title":"Build websites with Python &amp; Django"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#william-s-vincent","text":"","title":"William S. Vincent"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#create-a-folder-where-were-going-to-build-our-first-project","text":"mkdir code # Create a directory for our projects cd code # Change to that directory mkdir ch1-setup # Make a subdirectory for Chapter 1 cd ch1-setup # Change to that subdirectory","title":"Create a folder where we're going to build our first project."},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#to-create-a-virtual-environment-within-this-new-directory-use-the-format","text":"python3 -m venv <name_of_env> # This creates a venv It is up to the developer to choose a proper environment name but a common choice is to call it .venv. That hides the venv and is therefore one less piece of clutter on screens.","title":"To create a virtual environment within this new directory use the format:"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#activate-the-virtual-environment","text":"source .venv/bin/activate The shell prompt now has the environment name (.venv) prefixed which indicates that the virtual environment is active. Any Python packages installed or updated within this location will be confined to the active virtual environment. To deactivate and leave a virtual environment type deactivate .","title":"Activate the virtual environment"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#install-django","text":"python -m pip install django~=4.0.0 The comparison operator \u223c= ensures that subsequent security updates for Django, such as 4.0.1, 4.0.2, and so on are automatically installed. Note that while it is possible to use the shorter version of pip install , it is a best practice to use the longer but more explicit form of python -m pip install to ensure that the correct version of Python is used. This can be an issue if you have multiple versions of Python installed on your computer.","title":"Install Django"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#first-django-project","text":"A Django project can have almost any name but we will use django_project in this book. (.venv) > django-admin startproject django_project . It\u2019s worth pausing here to explain why you should add a period (.) to the end of the previous command. If you don't include the period, Django creates another django_project directory. This feels redundant to me which is why I prefer adding a period to the end which installs Django in the current directory.","title":"First Django Project"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#runserver-to-test-installation","text":"Now let\u2019s confirm everything is working by running Django\u2019s internal web server via the runserver command. This is suitable for local development purposes, but when it comes time to deploy our project\u2019s online we will switch to a more robust WSGI server like Gunicorn. python manage.py runserver","title":"Runserver to test installation"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_1_Initial_Setup/#code-editor-and-git","text":"Make sure you have a code editor and git installed. He recommends both the microsoft python extension for vscode and an extension called black which formats python code.","title":"Code Editor and Git"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/","text":"Django for Beginners Build websites with Python & Django William S. Vincent Chapter 2: Hello World App In this chapter we will build a Django project that simply says \u201cHello, World\u201d on the homepage. This is the traditional way to start a new programming language or framework. We\u2019ll also work with Git for the first time and deploy our code to GitHub. Initial Setup % cd ~/code % mkdir helloworld % cd helloworld Create a new virtual environment called .venv, activate it, and install Django with Pip as we did in the previous chapter. Now we\u2019ll use the Django startproject command to make a new project called django_project. Don\u2019t forget to include the period (.) at the end of the command so that it is installed in our current directory. ( .venv ) > django-admin startproject django_project . Django has added a django_project directory and a manage.py file. Within directory django_project are five new files: * __init__.py indicates that the files in the folder are part of a Python package. Without this file, we cannot import files from another directory which we will be doing a lot of in Django! * asgi.py allows for an optional Asynchronous Server Gateway Interface to be run * settings.py controls our Django project\u2019s overall settings * urls.py tells Django which pages to build in response to a browser or URL request * wsgi.py stands for Web Server Gateway Interface which helps Django serve our eventual web pages. The manage.py file is not part of django_project but is used to execute various Django commands such as running the local web server or creating a new app. Let\u2019s try out our new project by using Django\u2019s lightweight built-in web server for local development purposes. The command we\u2019ll use is runserver which is located in manage.py. Note that the full command line output will contain additional information including a warning about 18 unapplied migrations. Technically, this warning doesn\u2019t matter at this point. Django is complaining that we have not yet \u201cmigrated\u201d our initial database. Since we won\u2019t actually use a database in this chapter the warning won\u2019t affect the end result. However, since warnings are still annoying to see, we can remove it by first stopping the local server with the command Control+c and then running python manage.py migrate . What Django has done here is create a SQLite database and migrated its built-in apps provided for us. This is represented by the new file db.sqlite3 in our directory. The Django MVT pattern is as follows: * Model: Manages data and core business logic * View: Describes which data is sent to the user but not its presentation * Template: Presents the data as HTML with optional CSS, JavaScript, and Static Assets * URL Configuration: Regular-expression components configured to a View When you type in a URL, such as https://djangoproject.com, the first thing that happens within our Django project is a URL pattern (contained in urls.py) is found that matches it. The URL pattern is linked to a single view (contained in views.py) which combines the data from the model (stored in models.py) and the styling from a template (any file ending in .html). The view then returns a HTTP response to the user. Create an App Django uses the concept of projects and apps to keep code clean and readable. A single top-level Django project can contain multiple apps. Each app controls an isolated piece of functionality. For example, an e-commerce site might have one app for user authentication, another app for payments, and a third app to power item listing details. That\u2019s three distinct apps that all live within one top-level project. How and when you split functionality into apps is somewhat subjective, but in general, each app should have a clear function. ( .venv ) % python3 manage.py startapp pages If you look visually at the helloworld directory Django has created within it a new pages directory. Let\u2019s review what each new pages app file does: admin.py is a configuration file for the built-in Django Admin app apps.py is a configuration file for the app itself migrations/ keeps track of any changes to our models.py file so it stays in sync with our database models.py is where we define our database models which Django automatically translates into database tables tests.py is for app-specific tests views.py is where we handle the request/response logic for our web app Notice that the model, view, and url from the MVT pattern are present from the beginning. The only thing missing is a template which we\u2019ll add shortly. Even though our new app exists within the Django project, Django doesn\u2019t \u201cknow\u201d about it until we explicitly add it to the django_project/settings.py file. Add pages.apps.PagesConfig at the bottom. # django_project/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , \"django.contrib.auth\" , \"django.contrib.contenttypes\" , \"django.contrib.sessions\" , \"django.contrib.messages\" , \"django.contrib.staticfiles\" , \"pages.apps.PagesConfig\" , # new ] What is PagesConfig you might ask? Well, it is the name of the solitary function within the pages/apps.py file at this point. Create First View The next step is therefore to create our first view. Start by updating the views.py file in our pages app to look as follows: # pages/views.py from django.http import HttpResponse def homePageView ( request ): return HttpResponse ( \"Hello, World!\" ) There are two types of views in Django: function-based views (FBVs) and class-based views (CBVs). Our code in this example is a function-based view: it is relatively simple to implement and explicit. Django originally started with only FBVs but over time added CBVs which allow for much greater code reusability, keeps things DRY (Don\u2019t-Repeat-Yourself), and can be extended via mixins. The additional abstraction of CBVs makes them quite powerful and concise, however it also makes them harder to read for Django newcomers. Because web development quickly becomes repetitive Django also comes with a number of built- in generic class-based views (GCBVs) to handle common use cases such as creating a new object, forms, list views, pagination, and so on. We will be using GCBVs heavily in this book in later chapters. There are therefore technically three ways to write a view in Django: function-based views (FBVs), class-based views (CBVs), and generic class-based views (GCBVs). This customization is helpful for advanced developers but confusing for newcomers. Many Django developers\u2013including your author\u2013prefer to use GCBVs when possible and revert to CBVs or FBVs when required. We need to configure our URLs. In your text editor, create a new file called urls.py within the pages app. Then update it with the following code: # pages/urls.py from django.urls import path from .views import homePageView urlpatterns = [ path ( \"\" , homePageView , name = \"home\" ), ] On the top line we import path from Django to power our URL pattern and on the next line we import our views. By referring to the views.py file as .views we are telling Django to look within the current directory for a views.py file and import the view homePageView from there. Our URL pattern has three parts: * a Python regular expression for the empty string \"\" * a reference to the view called homePageView * an optional named URL pattern22 called \"home\" In other words, if the user requests the homepage represented by the empty string \"\", Django should use the view called homePageView. The last step is to update our django_project/urls.py file. It\u2019s common to have multiple apps within a single Django project, like pages here, and they each need their own dedicated URL path. # django_project/urls.py from django.contrib import admin from django.urls import path , include # new urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"\" , include ( \"pages.urls\" )), # new ] This need for two separate urls.py files is often confusing to beginners. Think of the top-level django_project/urls.py as the gateway to various url patterns distinct to each app. Git initialize (or add) Git to our repository. Make sure you\u2019ve stopped the local server with Control+c, then run the command git init. If you then type git status you\u2019ll see a list of changes since the last Git commit. Since this is our first commit, this list is all of our changes so far. Note that our virtual environment .venv is included which is not a best practice. It should be kept out of Git source control since secret information such as API keys and the like are often included in it. The solution is to create a new file called .gitignore which tells Git what to ignore. In this new file, add a single line for .venv. We do want a record of packages installed in our virtual environment. The current best practice is to create a requirements.txt file with this information. The command pip freeze will output the contents of your current virtual environment and by using the > operator we can do all this in one step: output the contents into a new file called requirements.txt. ( .venv ) > pip freeze > requirements.txt We next want to add all recent changes by using the command add -A and then commit the changes along with a message (-m) describing what has changed. ( .venv ) > git add -A ( .venv ) > git commit -m \"initial commit\" cd existing_repo git remote add origin https://gitlab.com/terryinfcco/hello-world.git git branch -M main git push -uf origin main Note I added an ssh key to gitlab from the beelink i5 kubuntu 21.10 upgraded to 22.04 build. I couldn't make the ssh work, so I finally did the git push with username and password, deleted all the local stuff and then cloned the hello-world repo using ssh. Now it works.","title":"Django for Beginners"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#django-for-beginners","text":"","title":"Django for Beginners"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#build-websites-with-python-django","text":"","title":"Build websites with Python &amp; Django"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#william-s-vincent","text":"","title":"William S. Vincent"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#chapter-2-hello-world-app","text":"In this chapter we will build a Django project that simply says \u201cHello, World\u201d on the homepage. This is the traditional way to start a new programming language or framework. We\u2019ll also work with Git for the first time and deploy our code to GitHub.","title":"Chapter 2: Hello World App"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#initial-setup","text":"% cd ~/code % mkdir helloworld % cd helloworld Create a new virtual environment called .venv, activate it, and install Django with Pip as we did in the previous chapter. Now we\u2019ll use the Django startproject command to make a new project called django_project. Don\u2019t forget to include the period (.) at the end of the command so that it is installed in our current directory. ( .venv ) > django-admin startproject django_project . Django has added a django_project directory and a manage.py file. Within directory django_project are five new files: * __init__.py indicates that the files in the folder are part of a Python package. Without this file, we cannot import files from another directory which we will be doing a lot of in Django! * asgi.py allows for an optional Asynchronous Server Gateway Interface to be run * settings.py controls our Django project\u2019s overall settings * urls.py tells Django which pages to build in response to a browser or URL request * wsgi.py stands for Web Server Gateway Interface which helps Django serve our eventual web pages. The manage.py file is not part of django_project but is used to execute various Django commands such as running the local web server or creating a new app. Let\u2019s try out our new project by using Django\u2019s lightweight built-in web server for local development purposes. The command we\u2019ll use is runserver which is located in manage.py. Note that the full command line output will contain additional information including a warning about 18 unapplied migrations. Technically, this warning doesn\u2019t matter at this point. Django is complaining that we have not yet \u201cmigrated\u201d our initial database. Since we won\u2019t actually use a database in this chapter the warning won\u2019t affect the end result. However, since warnings are still annoying to see, we can remove it by first stopping the local server with the command Control+c and then running python manage.py migrate . What Django has done here is create a SQLite database and migrated its built-in apps provided for us. This is represented by the new file db.sqlite3 in our directory. The Django MVT pattern is as follows: * Model: Manages data and core business logic * View: Describes which data is sent to the user but not its presentation * Template: Presents the data as HTML with optional CSS, JavaScript, and Static Assets * URL Configuration: Regular-expression components configured to a View When you type in a URL, such as https://djangoproject.com, the first thing that happens within our Django project is a URL pattern (contained in urls.py) is found that matches it. The URL pattern is linked to a single view (contained in views.py) which combines the data from the model (stored in models.py) and the styling from a template (any file ending in .html). The view then returns a HTTP response to the user.","title":"Initial Setup"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#create-an-app","text":"Django uses the concept of projects and apps to keep code clean and readable. A single top-level Django project can contain multiple apps. Each app controls an isolated piece of functionality. For example, an e-commerce site might have one app for user authentication, another app for payments, and a third app to power item listing details. That\u2019s three distinct apps that all live within one top-level project. How and when you split functionality into apps is somewhat subjective, but in general, each app should have a clear function. ( .venv ) % python3 manage.py startapp pages If you look visually at the helloworld directory Django has created within it a new pages directory. Let\u2019s review what each new pages app file does: admin.py is a configuration file for the built-in Django Admin app apps.py is a configuration file for the app itself migrations/ keeps track of any changes to our models.py file so it stays in sync with our database models.py is where we define our database models which Django automatically translates into database tables tests.py is for app-specific tests views.py is where we handle the request/response logic for our web app Notice that the model, view, and url from the MVT pattern are present from the beginning. The only thing missing is a template which we\u2019ll add shortly. Even though our new app exists within the Django project, Django doesn\u2019t \u201cknow\u201d about it until we explicitly add it to the django_project/settings.py file. Add pages.apps.PagesConfig at the bottom. # django_project/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , \"django.contrib.auth\" , \"django.contrib.contenttypes\" , \"django.contrib.sessions\" , \"django.contrib.messages\" , \"django.contrib.staticfiles\" , \"pages.apps.PagesConfig\" , # new ] What is PagesConfig you might ask? Well, it is the name of the solitary function within the pages/apps.py file at this point.","title":"Create an App"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#create-first-view","text":"The next step is therefore to create our first view. Start by updating the views.py file in our pages app to look as follows: # pages/views.py from django.http import HttpResponse def homePageView ( request ): return HttpResponse ( \"Hello, World!\" ) There are two types of views in Django: function-based views (FBVs) and class-based views (CBVs). Our code in this example is a function-based view: it is relatively simple to implement and explicit. Django originally started with only FBVs but over time added CBVs which allow for much greater code reusability, keeps things DRY (Don\u2019t-Repeat-Yourself), and can be extended via mixins. The additional abstraction of CBVs makes them quite powerful and concise, however it also makes them harder to read for Django newcomers. Because web development quickly becomes repetitive Django also comes with a number of built- in generic class-based views (GCBVs) to handle common use cases such as creating a new object, forms, list views, pagination, and so on. We will be using GCBVs heavily in this book in later chapters. There are therefore technically three ways to write a view in Django: function-based views (FBVs), class-based views (CBVs), and generic class-based views (GCBVs). This customization is helpful for advanced developers but confusing for newcomers. Many Django developers\u2013including your author\u2013prefer to use GCBVs when possible and revert to CBVs or FBVs when required. We need to configure our URLs. In your text editor, create a new file called urls.py within the pages app. Then update it with the following code: # pages/urls.py from django.urls import path from .views import homePageView urlpatterns = [ path ( \"\" , homePageView , name = \"home\" ), ] On the top line we import path from Django to power our URL pattern and on the next line we import our views. By referring to the views.py file as .views we are telling Django to look within the current directory for a views.py file and import the view homePageView from there. Our URL pattern has three parts: * a Python regular expression for the empty string \"\" * a reference to the view called homePageView * an optional named URL pattern22 called \"home\" In other words, if the user requests the homepage represented by the empty string \"\", Django should use the view called homePageView. The last step is to update our django_project/urls.py file. It\u2019s common to have multiple apps within a single Django project, like pages here, and they each need their own dedicated URL path. # django_project/urls.py from django.contrib import admin from django.urls import path , include # new urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"\" , include ( \"pages.urls\" )), # new ] This need for two separate urls.py files is often confusing to beginners. Think of the top-level django_project/urls.py as the gateway to various url patterns distinct to each app.","title":"Create First View"},{"location":"notes/django/Django_For_Beginners_Book/Chapter_2_Hello_World_App/#git","text":"initialize (or add) Git to our repository. Make sure you\u2019ve stopped the local server with Control+c, then run the command git init. If you then type git status you\u2019ll see a list of changes since the last Git commit. Since this is our first commit, this list is all of our changes so far. Note that our virtual environment .venv is included which is not a best practice. It should be kept out of Git source control since secret information such as API keys and the like are often included in it. The solution is to create a new file called .gitignore which tells Git what to ignore. In this new file, add a single line for .venv. We do want a record of packages installed in our virtual environment. The current best practice is to create a requirements.txt file with this information. The command pip freeze will output the contents of your current virtual environment and by using the > operator we can do all this in one step: output the contents into a new file called requirements.txt. ( .venv ) > pip freeze > requirements.txt We next want to add all recent changes by using the command add -A and then commit the changes along with a message (-m) describing what has changed. ( .venv ) > git add -A ( .venv ) > git commit -m \"initial commit\" cd existing_repo git remote add origin https://gitlab.com/terryinfcco/hello-world.git git branch -M main git push -uf origin main Note I added an ssh key to gitlab from the beelink i5 kubuntu 21.10 upgraded to 22.04 build. I couldn't make the ssh work, so I finally did the git push with username and password, deleted all the local stuff and then cloned the hello-world repo using ssh. Now it works.","title":"Git"},{"location":"notes/django/codemy_django_intro/00-Home/","text":"00-Codemy Django Intro Index Start a Django Project Add an App to the Project","title":"00-Codemy Django Intro Index"},{"location":"notes/django/codemy_django_intro/00-Home/#00-codemy-django-intro-index","text":"Start a Django Project Add an App to the Project","title":"00-Codemy Django Intro Index"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/","text":"Set up a Development Environment install Python3 install Pip3 install venv You need a text editor Make sure you have a terminal app / a command line. Create a Virtual Environment mkdir code # Create a directory for our code cd code # change to the code directory python3 -m venv venv # Creates a venv named venv source venv/bin/activate # activates the venv pip freeze # shows a list of what's installed in the venv Install Django - make sure venv is active pip install django Create a new Django Project # Make sure you're in code and the venv is active mkdir djangoproject cd djangoproject django-admin startproject mysite . # This creates a mysite subdirectory and a manage.py file Run the Django Devlopment Server # Make sure you're in code/djangoproject python manage.py runserver # go to localhost:8000 in a browser to make sure you get successful install screen Fix the migration errors # To fix the initial migrations errors you get python3 manage.py migrate # This also creates the admin section which can be accessed at localhost:8000/admin Create the Superuser python manage.py createsuperuser # give a username, email, and password # Now can login at localhost:8000/admin/ Notes I think I did the last two steps on the pi 400 in the basement, but they didn't exist when I moved upstairs. So they either don't get put on gitlab or I forgot to do a git push at the end.","title":"01 Stuff For Every Django Project"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#set-up-a-development-environment","text":"install Python3 install Pip3 install venv You need a text editor Make sure you have a terminal app / a command line.","title":"Set up a Development Environment"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#create-a-virtual-environment","text":"mkdir code # Create a directory for our code cd code # change to the code directory python3 -m venv venv # Creates a venv named venv source venv/bin/activate # activates the venv pip freeze # shows a list of what's installed in the venv","title":"Create a Virtual Environment"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#install-django-make-sure-venv-is-active","text":"pip install django","title":"Install Django - make sure venv is active"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#create-a-new-django-project","text":"# Make sure you're in code and the venv is active mkdir djangoproject cd djangoproject django-admin startproject mysite . # This creates a mysite subdirectory and a manage.py file","title":"Create a new Django Project"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#run-the-django-devlopment-server","text":"# Make sure you're in code/djangoproject python manage.py runserver # go to localhost:8000 in a browser to make sure you get successful install screen","title":"Run the Django Devlopment Server"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#fix-the-migration-errors","text":"# To fix the initial migrations errors you get python3 manage.py migrate # This also creates the admin section which can be accessed at localhost:8000/admin","title":"Fix the migration errors"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#create-the-superuser","text":"python manage.py createsuperuser # give a username, email, and password # Now can login at localhost:8000/admin/","title":"Create the Superuser"},{"location":"notes/django/codemy_django_intro/01-Stuff_For_Every_Django_Project/#notes","text":"I think I did the last two steps on the pi 400 in the basement, but they didn't exist when I moved upstairs. So they either don't get put on gitlab or I forgot to do a git push at the end.","title":"Notes"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/","text":"02-These Are Steps to Add an App to a Django Project Create the App An app is one section of a large website, but this project has only one app. python manage.py startapp pages # Creates code/djangoproject/pages Add the App to the Project In code/djangoproject/mysite/settings.py add 'pages', to INSTALLED_APPS list. Add urls.py at app level It's cleaner to keep urls separated by app. So in code/djangoproject/pages create urls.py. Then set up a skeleton in the new urls.py from django.urls import path urlpatterns = [] Create the Views Every web page created in our app has to have a view so in pages/views.py: from django.shortcuts import render def home ( request ): return render ( request , \"home.html\" , {}) def about ( request ): return render ( request , \"about.html\" , {}) In each function, request is required, the html files are the names of the templates we're going to use. {} is a dictionary that we can use to pass data to the template Add Templates Add a subdirectory in pages called templates. Create home.html and about.html and add a header in each page. HOME PAGE and ABOUT PAGE. Add the views to pages/urls.py # import the views.py file so we can connect them to urls. from . import views # Then in usrpatterns list add a url for each view path ( '' , views . home , name = 'home' ), path ( 'about/' , views . about , name = 'about' ), # First is the page name that follows localhost:8000, # Then the name of the function in views.py that we're attaching to that url, # Then a name we can use for linking to this page. Link App urls.py to Project urls.py So in project urls.py from django.urls import path, include # then add to urlpatterns list path('', include('pages.urls)),","title":"02-These Are Steps to Add an App to a Django Project"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#02-these-are-steps-to-add-an-app-to-a-django-project","text":"","title":"02-These Are Steps to Add an App to a Django Project"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#create-the-app","text":"An app is one section of a large website, but this project has only one app. python manage.py startapp pages # Creates code/djangoproject/pages","title":"Create the App"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#add-the-app-to-the-project","text":"In code/djangoproject/mysite/settings.py add 'pages', to INSTALLED_APPS list.","title":"Add the App to the Project"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#add-urlspy-at-app-level","text":"It's cleaner to keep urls separated by app. So in code/djangoproject/pages create urls.py. Then set up a skeleton in the new urls.py from django.urls import path urlpatterns = []","title":"Add urls.py at app level"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#create-the-views","text":"Every web page created in our app has to have a view so in pages/views.py: from django.shortcuts import render def home ( request ): return render ( request , \"home.html\" , {}) def about ( request ): return render ( request , \"about.html\" , {}) In each function, request is required, the html files are the names of the templates we're going to use. {} is a dictionary that we can use to pass data to the template","title":"Create the Views"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#add-templates","text":"Add a subdirectory in pages called templates. Create home.html and about.html and add a header in each page. HOME PAGE and ABOUT PAGE.","title":"Add Templates"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#add-the-views-to-pagesurlspy","text":"# import the views.py file so we can connect them to urls. from . import views # Then in usrpatterns list add a url for each view path ( '' , views . home , name = 'home' ), path ( 'about/' , views . about , name = 'about' ), # First is the page name that follows localhost:8000, # Then the name of the function in views.py that we're attaching to that url, # Then a name we can use for linking to this page.","title":"Add the views to pages/urls.py"},{"location":"notes/django/codemy_django_intro/02-Set_Up_App/#link-app-urlspy-to-project-urlspy","text":"So in project urls.py from django.urls import path, include # then add to urlpatterns list path('', include('pages.urls)),","title":"Link App urls.py to Project urls.py"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/","text":"03-Django Basics Creating Links You could use regular old html links: < a href = \"/\" > Home </ a > | < a href = \"/about\" > About </ a > But it's more flexible and easier to change later if necessary if we use Django links: < a href = \"{% url 'home' %}\" > Home </ a > | < a href = \"{% url 'about' %}\" > About </ a > The 'home' and 'about' refer to the names in the urlpatterns list in urls.py. Later if we want to change a path, we don't have to change it on every page, we just have to change the path in urls.py. Extends Base File Sharing common things among web pages. Create a template file called base.html in pages/templates and paste the bootstrap template. At beginning of body in base.html put a block where the code that's unique to the various web pages goes. {% block content %} {% endblock %} Then in each web page put the content of that web page in: {% extends 'base.html' %} {% block content %} <h1> Home Page </h1> {% endblock %} Block Title This will allow unique titles on each page of the website (what goes on the tab in the browser) So in about.html he put: {% block title %} About John Elder {% endblock %} This is a separate block from block content and isn't nested. Then in base.html: <title> {% block title %} Hello, world! {% endblock %} </title> What happens is if the page we're displaying has a block named title, that name will be used, so in the above example the about page will show About John Elder. However on a page that doesn't have a block named title we'll see Hello, world! (like on our home page since we haven't added a block title to it). Add a Navbar Grabs the navbar example at the top of the Bootstrap 4.1 Components navbar page and pastes it into base.html right below the opening body tag. At the opening nav tag, he changed navbar-light to navbar-dark and bg-light to bg-dark. Again in base.html, he wraps the block content and endblock statements in a div with the class of container, and adds a line break above the div that he just added. Then clean up the navbar. Delete the form that's a search box. Deletes the dropdown menu. Deletes the disabled link, and the home link. Change the label that says Navbar to John Elder. Then change the navbar links to Django style: <li class=\"nav-item\"> <a class=\"nav-link\" href=\" {% url 'home' %} \">Home</a> </li> <li class=\"nav-item\"> <a class=\"nav-link\" href=\" {% url 'about' %} \">About</a> </li>","title":"03-Django Basics"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/#03-django-basics","text":"","title":"03-Django Basics"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/#creating-links","text":"You could use regular old html links: < a href = \"/\" > Home </ a > | < a href = \"/about\" > About </ a > But it's more flexible and easier to change later if necessary if we use Django links: < a href = \"{% url 'home' %}\" > Home </ a > | < a href = \"{% url 'about' %}\" > About </ a > The 'home' and 'about' refer to the names in the urlpatterns list in urls.py. Later if we want to change a path, we don't have to change it on every page, we just have to change the path in urls.py.","title":"Creating Links"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/#extends-base-file","text":"Sharing common things among web pages. Create a template file called base.html in pages/templates and paste the bootstrap template. At beginning of body in base.html put a block where the code that's unique to the various web pages goes. {% block content %} {% endblock %} Then in each web page put the content of that web page in: {% extends 'base.html' %} {% block content %} <h1> Home Page </h1> {% endblock %}","title":"Extends Base File"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/#block-title","text":"This will allow unique titles on each page of the website (what goes on the tab in the browser) So in about.html he put: {% block title %} About John Elder {% endblock %} This is a separate block from block content and isn't nested. Then in base.html: <title> {% block title %} Hello, world! {% endblock %} </title> What happens is if the page we're displaying has a block named title, that name will be used, so in the above example the about page will show About John Elder. However on a page that doesn't have a block named title we'll see Hello, world! (like on our home page since we haven't added a block title to it).","title":"Block Title"},{"location":"notes/django/codemy_django_intro/03-Django-Basics/#add-a-navbar","text":"Grabs the navbar example at the top of the Bootstrap 4.1 Components navbar page and pastes it into base.html right below the opening body tag. At the opening nav tag, he changed navbar-light to navbar-dark and bg-light to bg-dark. Again in base.html, he wraps the block content and endblock statements in a div with the class of container, and adds a line break above the div that he just added. Then clean up the navbar. Delete the form that's a search box. Deletes the dropdown menu. Deletes the disabled link, and the home link. Change the label that says Navbar to John Elder. Then change the navbar links to Django style: <li class=\"nav-item\"> <a class=\"nav-link\" href=\" {% url 'home' %} \">Home</a> </li> <li class=\"nav-item\"> <a class=\"nav-link\" href=\" {% url 'about' %} \">About</a> </li>","title":"Add a Navbar"},{"location":"perhaps/three_websites/","text":"The three websites are todo/perhaps, blog/learning log, and notes. Maybe set up a set of scripts and maybe a bash menu that would let me add a new todo, edit existing todos, add a new blog entry, etc.","title":"Three websites"},{"location":"perhaps/udemy/","text":"Maybe work out which courses you actually want to take. You've got several web development courses and several python courses. Maybe you should pick one web development course and finish it, then pick up pieces of the other courses that weren't covered in the one you did.","title":"Udemy"},{"location":"todo/todo_list/","text":"Fix up this todo list and write up instructions on how it might work.","title":"Todo list"},{"location":"todo/udemy/","text":"I really need to get back at all my udemy courses and work through them.","title":"Udemy"}]}